---
title: "VueにおけるVeeValidateとZodを用いたフォーム設計戦略"
emoji: "🐝"
type: "tech"
topics: ["frontend", "vue", "nuxt", "VeeValidate"]
published: false
---

# 1. はじめに

## 1.1 Vue.jsとフォームバリデーションの重要性

Webアプリケーションの開発において、フォームの利用は欠かせない要素である。ユーザーからのデータ入力を受け付けるため、正確で信頼性のあるバリデーションが必要不可欠です。特にVue.jsのようなフロントエンドフレームワークを使用する場合、フォームバリデーションの実装はシームレスかつ効率的に行えるようになっている

従来のマルチページアプリケーションではユーザーがフォームを送信する前に、ページ全体を再読み込みする必要があった。そのため、ユーザーが入力エラーを発見するまでの間、エラーメッセージやフィードバックは表示されず、ユーザーは何が間違っているのかを理解するために、フォームを再度送信する必要があった。このようなユーザーエクスペリエンスは、ユーザーがアプリケーションを使用する際にストレスを感じる原因となる。また、ユーザーがフォームを送信するたびに、サーバーにリクエストを送信する必要があるため、パフォーマンスの観点からも効率的ではない。

しかしSPAにおけるリアルタイムなフォームのバリデーションはユーザーエクスペリエンスの向上やパフォーマンスの最適化などの利点を提供する。ユーザーが入力エラーを即座に確認できるため、エラーが発生したフィールドをすぐに修正することができます。これにより、ユーザーはスムーズな操作が可能となり、不要なエラーによるフラストレーションを軽減できる。

またSPAによるリアルタイムフォームバリデーションは、サーバーサイドへの不要なリクエストを削減し、パフォーマンスを最適化するのにも役立つ。入力エラーが即座に検出されるため、不正なデータを送信する前にサーバーサイドへのリクエストを行う必要がない。これにより、ネットワークのトラフィックやサーバーの負荷を軽減することもできる

リアルタイムフォームバリデーションは、SPAにおいてユーザーエクスペリエンスの向上、データの正確性と信頼性の確保、パフォーマンスの最適化といった利点をもたらす。そのため、Vue.jsなどのSPAフレームワークでのフォーム設計において、リアルタイムフォームバリデーションを適切に実装することは重要である

## 1.2 VeeValidateとZodの紹介

Vue.jsには、フォームバリデーションを容易に行うためのさまざまなライブラリが存在するが、本記事では特にVeeValidateとZodに注目したいと思う。VeeValidateは、Vue.js向けに作られた強力なバリデーションライブラリであり、簡潔なルールの定義やカスタマイズ性に優れています。一方、ZodはTypeScript向けのスキーマ定義とバリデーションライブラリであり、型安全性と柔軟なバリデーションルールの定義が特徴である。

この記事では、Vue.jsでVeeValidateとZodを組み合わせることで、強力なフォームバリデーションの設計戦略を構築する方法について詳しく解説したい

### 1.2.1 VeeValidateの概要と利点

VeeValidateは、フォームフィールドの入力が変更されるたびにリアルタイムにバリデーションを実行する。これにより、ユーザーが入力エラーを即座に検出し修正することができるようになる。エラーメッセージやスタイリングを適切に設定することで、ユーザーにわかりやすいフィードバックを提供できる。

またVeeValidateにより、Zodに対応した拡張機能が提供されている。これにより、Zodのスキーマ定義をVeeValidateのルールとして利用することができる。これにより、VeeValidateの柔軟なバリデーションルールとZodの型安全性を組み合わせた開発をすることができる。

### 1.2.2 Zodの概要と利点

Zodは、データのバリデーションとスキーマ定義を行うためのライブラリである。Zodを使用することで、データの構造や制約を明確に定義し、入力値のバリデーションを実行することができる。さらに、Zodは型安全性を提供し、TypeScriptの恩恵を最大限に受けることができるようになっている。

Zodのスキーマ定義により、正しいデータ型やプロパティを持つオブジェクトが利用されることを保証することができる。これにより、開発時のエラーを事前に検知し、安全で信頼性の高いコードを実現する。

Zodでは、柔軟かつ強力なバリデーションルールを定義することができる。データの必須項目、最小値や最大値、正規表現によるパターンマッチングなど、さまざまなバリデーション制約を指定することができる。また、複雑なネストされたオブジェクトや配列のバリデーションもサポートされている。

# 4. VeeValidateとZodの統合

## 4.1 VeeValidateとZodを@vee-validate/zodを使って統合する

@vee-validate/zodでは、toTypedSchemaメソッドを使用して、ZodのスキーマをVeeValidateのバリデーションスキーマに変換することができます。これにより、Zodで定義した厳密なバリデーションルールをVeeValidateのフォームバリデーションに簡単に統合することができます。

以下は、toTypedSchemaを使用してZodスキーマをVeeValidateのバリデーションスキーマに統合するコードの例です。

```ts
import { useForm } from '@vee-validate/core';
import { toTypedSchema } from '@vee-validate/zod';
import { object, string } from 'zod';

const { values, handleSubmit } = useForm({
  validationSchema: toTypedSchema(
    object({
      email: string()
          .email('メールアドレスの形式が正しくありません')
          .min(1, 'メールアドレスを入力してください'),
      name: string().min(1, '名前を入力してください'),
    })
  ),
});
```

これで型安全なバリデーションスキーマを定義することができる

## 4.2 v4.8からtoFieldValidator、toFormValidatorは非推奨。toTypedSchemaを使うこと

@vee-validate/zodのバージョン4.8以降では、toFieldValidatorやtoFormValidatorといった関数は非推奨となりました。代わりに、toTypedSchemaを使用することが推奨されています

理由としてはv4.8よりVeeValidateでは**入力型**と**出力型**を区別する必要があるためだ。先程のコードを読んでみると、valuesの型は入力型になっている。実際にemailとnameついている型は以下のとおりだ

```ts
type Value = {
  email: string | undefined;
  name: string | undefined;
}
```

上記のuseFormでuseFormの引数にinitialValuesを指定していない。そのためvaluesの初期値はundefinedとなる

これにより、より型安全な開発を行うことができる。ではschemaどおりの出力型がついた値を使うにはどうすればいいか。考えられる方法としては2通りある

1. valuesをschemaを使ってparseする方法
2. submit時にhandleSubmitの引数からvalueを参照する方法

まずは1つ目の方法だ

```ts
import { useForm } from '@vee-validate/core';
import { toTypedSchema } from '@vee-validate/zod';
import { object, string } from 'zod';

const schema = object({
    email: string()
      .email('メールアドレスの形式が正しくありません')
      .min(1, 'メールアドレスを入力してください'),
    name: string().min(1, '名前を入力してください'),
})

const { values, handleSubmit } = useForm({
  validationSchema: toTypedSchema(schema),
  initialValues: {
    email: '',
    name: ''
  }
});

const parsedValues = schema.parse(values)

/*
* {
*   email: string;
*   name: string;
* }
*/
console.log(parsedValues)
```

出力されたparsedValuesの型はコメントの通りである。これでschemaどおりの出力型を得ることができた。もちろん初期値を定義していなければエラーになるので注意は必要だ

それでは2つ目の方法だ。これはフォームを送信した結果としての

# 5. VeeValidateとZodを用いたフォーム設計戦略のプラクティス考察

## 5.1 シンプルなコンポーネント設計

## 5.2 出力型による型安全性とユーザビリティを意識したフォーム設計

## 5.3 確認画面はSPAで一画面で設計するか、別画面で設計するか

## 5.4 フォーム送信とサーバーサイドのバリデーション

## 5.5 フォームのテスト戦略

# まとめ

