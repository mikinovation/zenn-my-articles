---
title: "新しいReactのドキュメントで副作用について読む"
emoji: "✍"
type: "tech"
topics: ["react", "frontend"]
published: false
---

:::message
Reactの新ドキュメントは執筆時点でβ版です。
今後内容が修正、更新される可能性がありますのでご注意ください
また本記事はまとめ記事であり、内容を一部改変、省略しておりますのでご了承下さい
:::

# はじめに

## 対象者

今回の読者は以下の様な方を想定している

- Reactのアプリケーションの開発経験がある方
- Reactにおけるの副作用の知識を深めたい方
- Reactアプリケーションのパフォーマンスチューニングをしたいと思っている方
- 旧Reactのドキュメントを読まれている方

## 新ドキュメントと旧ドキュメントの違い

新ドキュメントはReactの具体的なノウハウが詰まっており非常に濃いです

## EffectとSide Effectの訳に関して

新ドキュメントには「Effect」と「Side Effect」という言葉が度々登場する

英語原文では 「Effect」と「Side Effect」の違いを以下のように定義している

- Effect: 頭文字が大文字の場合はReact固有の定義、すなわちレンダリングによって引き起こされる副作用を指す
- Side Effect: プログラミングにおける広義な意味での副作用を指す

本記事ではこの違いを明確に区別するため、以下のように訳すものとする

- Effect: エフェクト
- Side Effect: 副作用

# エフェクトによる同期

Reactにおいていくつかのコンポーネントは(Web APIやログ等を利用して)外部システムとデータを同期させる必要がある。

エフェクトを引き起こすことによって同期することをあげると以下のようなものがある

- reactの状態に基づいた非Reactのコンポーネントの状態
- サーバーとの通信
- ログの出力

等

レンダリング時やイベントハンドリング時に作用を発生させることでReactアプリケーションは外部システムとデータを同期させることが可能である

## エフェクトとは何か。イベントとの違い

Reactコンポーネント内のロジックには以下2つの種類があることを知っておかなければならない

### Rendering code

レンダリングコードはUIを表現する。

propsを受け取ったりstateを管理し、また状態に応じてUIをJSXで記述することができる

HaskellやElm等純粋関数型プログラミングによる関数型言語に馴染みのある方ならご存知かもしれないが、関数は

- 関数の外側の影響を受けていない。処理が関数内に閉じていること
- 引数が同じであれば毎回同じ結果を返すこと

を満たすことが望ましい。そして関数がこれらの状態であることを「純粋な関数である」と表現する

そしてRendering codeは純粋でなければならない。

### Event handlers

イベントハンドラーはコンポーネントに対してインタラクションをもたらす。

イベントハンドラーには以下のような役割がある

- input fieldを更新する
- Web APIサーバーにリクエストを送信する
- ユーザーを別画面に遷移させる

等

イベントハンドラーは副作用を引き起こす。ユーザーのクリックやキーボードのタイプによってプログラムの状態が更新されることがある

しかしこれだけではない。副作用はあるユーザーのアクションからだけでなく、レンダリングそのものによって発生することもある。典型的な例がChat機能であり、Web Socket通信やPolling等の技術を利用することでサーバーとコネクションをつなぐ。

Reactはあるイベントが「トリガー」となり、画面が「レンダリング」され、DOMへ変更を「コミット」している。この「トリガー」「レンダリング」「コミット」の3ステップがReactのレンダリングプロセスであるが、このレンダリングプロセス終了時に副作用が発火されることもある。

## エフェクトの書き方



1. 副作用を宣言する
2. 副作用の依存性を特定する
3. 必要であればcleanupする

## 開発において２回発火する副作用をどう扱うか

### non-React widgetsの制御

### イベントの購読

### アニメーションを引き起こす

### データを取得する

### 分析を行う

### アプリケーションの初期化(エフェクトではない)

### 商品を買う(エフェクトではない)

# あなたのエフェクトは必要ないかもしれない

## 不必要なエフェクトの除去

### propsやstateの値に応じてstateを更新する

### 無駄な計算をキャッシュする

### propsが変化したときに全てのstateを更新する

### propsが変化したときに、いくつかのstateを更新する

### イベントハンドラー間でロジックを共有する

### POSTリクエストを送信する

### 計算の連鎖

### アプリケーションの初期化

### 親コンポーネントにstateの変化を伝える

### 親コンポーネントにデータを渡す

### 外部storeを購読する

# リアクティブな副作用のライフサイクル

## 副作用のライフサイクル

### なぜ何回も同期が必要なのか

### ReactがどのようにEffectを同期するか

### 副作用の観点からの考察

### Reactがどのように副作用が再同期されたかを立証するか

### Reactがどのように副作用を再同期が必要だと判断するか

### 各副作用は個別の動機処理を表す

## Reactiveな値に反応する副作用

### 空の依存性による副作用が意味するものとは

### コンポーネント内で宣言された全ての変数はリアクティブである

### Reactはすべてのリアクティブな値を依存関係として指定したことを確認する

### もし再同期したくない場合はどうするべきか

# 副作用からイベントを分離する

## イベントハンドラーか副作用を選ぶ

### 特定のインタラクションに対して実行されるイベントハンドラー

### 同期が必要な場合には副作用がいつでも走る

## リアクティブな値とリアクティブなロジック

### イベントハンドラー内のロジックはリアクティブでない

### 副作用内のロジックはリアクティブである

## 副作用からリアクティブでないロジックを抽出する

### イベント関数を宣言する

### イベント関数で最新のpropsとstateを取得する

### イベント関数の制限

# まとめ