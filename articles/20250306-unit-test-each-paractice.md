# 単体テストにおける `test.each` のプラクティス再考

```message
今回はJavascriptのVitestにおける `test.each` を例に使用しますが、他のテストフレームワークでも考え方は同様です。
また言語によってベストプラクティスが異なる場合もあるので、その点はご留意ください。
```

## 1. はじめに

こんにちは、普段Webエンジニアをしている齋藤です。

皆さん、単体テストを書くときに`test.each`を使用されているでしょうか？`test.each`は特に、複数のテストケースをまとめて書くときに便利な機能です。

しかし、その使い方には注意が必要です。書き方を間違えると可読性が下がったり、テストの意図が分かりにくくなったりすることがあります。

私は今までこの`test.each`のプラクティスに書かれた記事を見たことがありませんでした。そこで今回は、`test.each`の書き方について考察し、実践的なプラクティスを考察してみたいと思います。

### 1.1. `test.each` とは何か？

`test.each`は、複数のテストケースをまとめて書くための関数です。配列を使って、入力と期待値のペアを指定することで、複数のテストケースを一度に書くことができます。

具体的な例を見てましょう。

```ts
function add(a: number, b: number): number {
  return a + b;
}

describe('add', () => {
  test.each([
    [1, 2, 3],
    [0, 0, 0],
    [-1, 1, 0],
  ])('aが %i, bが %i のとき、%i が返されること', (a, b, expected) => {
    expect(add(a, b)).toBe(expected);
  });
});
```

この例では、`add`関数に対して3つのテストケースを書いています。それぞれのテストケースは、入力と期待値のペアで表現されています。

上記の例でいうと次の3つのテストケースが書かれています。

- `a`が1、`b`が2のとき、3が返されること
- `a`が0、`b`が0のとき、0が返されること
- `a`が-1、`b`が1のとき、0が返されること

このように、`test.each`を使うことで、複数のテストケースを一度に書くことができます。非常に便利な機能です。

### 1.2. なぜこの書き方について考えるのか？

では、なぜこの書き方について考察しようと思ったのか、その理由をいくつか挙げてみましょう。

#### チームで書き方が統一されていない問題

コードを書くときは、チームで書き方が統一されていることはとても重要です。チームでコーディング規約を決められていることが多いでしょう

しかし、単体テストはどうでしょうか？自分はあまり単体テストの記法に関しては気にしていない、という人も多いかもしれません。

しかし単体テストもコードの一部であり、コードと同じように書き方が統一されていることが望ましいです。`test.each`を使う場合も、どのように書くかについても統一されたルールがあるとよいでしょう。

#### 可読性が下がる問題

#### テストの意図が分かりにくい問題

## 2. `test.each` の書き方のパターンとその比較

プロジェクトによって、`test.each` の書き方は様々です。ここでは、私が見かけた3つのパターンを紹介し、それぞれの特徴を比較してみましょう。

```ts
const func1 = (a: string, b: number, c: number) => {
  if(a === 'soemthing') {
    return 0
  }

  return b + c
}
```

ここに「特に意味はない関数」が存在します。この関数に対してVitestでテストを書いてみます。

### パターン①：説明を配列に含める

まずは、説明を配列に含めるパターンです。

```ts
describe('func1', () => {
  test.each([
    ['aがsomethingで、bが1、cが2の場合', 'something', 1, 2, 0],
    ['aがtestで、bが1、cが2の場合', 'test', 1, 2, 3],
    ['aがanotherで、bが1、cが2の場合', 'another', 1, 2, 3],
  ])('%s', (_, a, b, c, expected) => {
    expect(func1(a, b, c)).toBe(expected)
  })
})
```

この書き方の特徴は、説明を配列に含めることです。`%s` で説明を受け取り、それをテストの説明として使います。この書き方のメリットは、説明が一箇所にまとまっているため、見やすいことです。

しかしデメリットもあります。以下の画像を見てみましょう。あえて2つ目のテストに失敗するようにしています。

あとで画像用意
![パターン①の失敗例](./images/20250306-unit-test-each-paractice-01.png)

行数に注目してみてください。17行目で失敗していることが分かります。Vitestの場合は、失敗したテストの説明が右上に表示されどのテストが失敗したのか分かりやすいので良さそうですね

もちろんデメリットもあります。まずパラーメーターごとに絞ってテストを実行することはできません。

以前筆者がJavaをIntelliJ IDEAで書いていたときのことです。複雑なパラメーターのビジネスロジックで大量のテストケースを書いていました。一度にテストを実行すると非常にストレスを感じます。ただその時はeachのようめメソッドは利用せず、個別のtestを実行することができたので問題なくテストを書くことができていました。

これはプロジェクトや使用する言語によって違うかもしれませんが、筆者は各パラメータのテストを個別に書くことが大きなメリットになりうると思っています。

もう一点はテストの意図が分かりにくくなる可能性があることです。今回は3つのパラメータのみでシンプルなプリミティブ型のみからなる関数を対象にしています。しかし、もしパラメータが増えたり、複雑なオブジェクトを扱うような関数だった場合、テストの意図が分かりにくくなる可能性があります。

### パターン②：パラメータのみを配列に含める

次に、パラメータのみを配列に含めるパターンです。

```ts
describe('func1', () => {
  test.each([
    ['something', 1, 2, 0],
    ['test', 1, 2, 3],
    ['another', 1, 2, 3],
  ])('aが %s で、bが %i、cが %i の場合、%i が返されること', (a, b, c, expected) => {
    expect(func1(a, b, c)).toBe(expected)
  })
})
```

この書き方の特徴は、パラメータのみを配列に含めることです。`%s`、`%i` でパラメータを受け取り、それをテストの説明に使います。この書き方のメリットは、パラメータが一箇所にまとまっているため、見やすいことです。

しかしデメリットもあります。以下の画像を見てみましょう。あえて2つ目のテストに失敗するようにしています。

// TODO: 画像を追加する

こちらもパターン①と同様に、失敗したテストの説明が右上に表示されています。説明は分かりやすいのですが、問題は失敗したテストがどれなのか見つけにくいという問題があります。

### パターン③：すべて個別の `test` で書く

describe('func1', () => {
  test('aがsomethingの場合、0を返す', () => {
    expect(func1('something', 1, 2)).toBe(0);
  });

  test('aがtestの場合、3を返す', () => {
    expect(func1('test', 1, 2)).toBe(3);
  });

  test('aがanotherの場合、30を返す', () => {
    expect(func1('another', 10, 20)).toBe(30);
  });
});

この書き方の特徴は、それぞれテストケースを個別に書くことにあります。この書き方のメリットは、テストが失敗したときに、どのテストが失敗したのかが一目で分かることです。

それでは実際に試してみましょう

// TODO: 画像を追加する

行数に着目してみてください。17行目で失敗していることが分かります。筆者はVimを利用しているため行数はとても大きな役割を持ちます。17行目であれば`17G`と入力することでその行へ瞬時に移動することが可能です。

条件ごとに明確なテストの意図を示すこともできます。筆者はプロダクトに実装を追加してテストが失敗した際に、そのテストだけではなく前後のテストケースを確認します。前後のテストケースを確認することで、どのようなテストを行っているのかが明確になるからです

もちろんデメリットもあります。テストケースが増えると冗長になりやすいという点が挙げられます。同じようなテストケースの文章を何度も書くことになるからです。

## 4. `test.each` を使うべきケース・使うべきでないケース
- 入力と期待値のパターンが明確な関数（例: バリデーション関数）は `test.each` に向いている
- 条件分岐が多く、テストの意図を明示したい場合は個別の `test` のほうがよい

## 5. 実践的なベストプラクティス
- 読みやすさを重視するなら `describe` の中で `test.each` を適切に使う
- ケースごとに観点を分けて整理する（例: 「エッジケース」と「通常ケース」を分ける）
- テストが失敗したときに、どのケースで失敗したのか分かりやすくする工夫

## 6. まとめ
- `test.each` を使うかどうかは好みの問題ではなく、状況に応じた選択が重要
- チーム内で統一するための基準を決めるのがベスト

